// vis_struct_gen
//
// used to generate the system verilog and c++ header files from the input JSON description of the 
// visualisation structures
//
// author: stf

#include <iostream>
#include <string>
#include <boost/program_options.hpp>
using namespace boost::program_options;

#include <vector>
#include <string>

#include "rapidjson/document.h"
#include "rapidjson/filereadstream.h"

#include "VisStruct.hpp"
#include "RenderCpp.hpp"

// recursively walks over the visualisation structure
void walkStructure_r(const rapidjson::GenericValue<rapidjson::UTF8<> >& jin, VisStruct* sin, bool silent, std::vector<std::string> *exists_check) {
    sin->name(jin["struct_name"].GetString());

    // iterate through the signals and add them
    for(auto const& in : jin["signals"].GetArray()) {
        if(in.HasMember("name")) {
            if(!silent)
         	fprintf(stdout, "found signal: %s\n", in["name"].GetString());
	    
	    VisSignal t_sig(in["name"].GetString(), in["width"].GetInt());
	    sin->add(t_sig);
		
	    // check to make sure it doesn't exist already
	    for(std::vector<std::string>::iterator it=exists_check->begin(); it!=exists_check->end(); ++it){
		std::string c = *it;
		if(c == in["name"].GetString()){
			fprintf(stderr, "\n\nError! %s defined twice, the tool currently needs a unique name for all signals, even ones within a different scope.\n\n\n", c.c_str());
			exit(-1);
		}
	    }

	    exists_check->push_back(in["name"].GetString());

	}
	if(in.HasMember("struct_name")) {
	   if(!silent) 
		   fprintf(stdout, "Adding Struct: %s\n", in["struct_name"].GetString());
           VisStruct t_struct;
	   walkStructure_r(in, &t_struct, silent, exists_check);
	   sin->add(t_struct);
	}
    }
}

void walkStructure(const rapidjson::GenericValue<rapidjson::UTF8<> >& jin, VisStruct* sin, bool silent) {
	std::vector<std::string> *exists_check = new std::vector<std::string>();
	walkStructure_r(jin, sin, silent, exists_check); 
	delete exists_check;
}

void verilogWalk(FILE* fp, VisStruct s) {
	for(VisStruct::iterator sin=s.begin(); sin != s.end(); ++sin) {
		VisStruct t = (*sin).second;
		verilogWalk(fp, t);
	}
	s.verilog(fp);	
}

// recursively walks the structure and generates the verilog for it
void emitVerilog(FILE* fp, VisStruct s) {
    fprintf(fp, "// Autogenerated Verilog visualisation types file, this should not be edited manually\n\n");
    fprintf(fp, "package Draigi32Vis;\n\n");            
    verilogWalk(fp, s);
    fprintf(fp, "\nendpackage\n");
}

int main(int argc, char* argv[])
{
    try {
        std::string jsonin;
	std::string cppout;
	std::string svout;
	bool silent = false;
    
	options_description desc("Allowed options");
	desc.add_options()
		("help,h", "print usage message")
		("input,i", value<std::string>()->default_value("vis_struct.json"))
		("cpp,c", value<std::string>()->default_value("vis_struct.hpp"))
		("sv,v", value<std::string>()->default_value("vis_struct.sv"))
		("silent,s",bool_switch(&silent), "silences the output");

	variables_map vm;
	store(command_line_parser(argc, argv).options(desc).run(), vm);
	notify(vm);

	if(vm.count("help")) {
            std::cout << desc << "\n";
	    return 0;
	}

	jsonin = vm["input"].as<std::string>();
	cppout = vm["cpp"].as<std::string>();
	svout  = vm["sv"].as<std::string>();

    // ~~=~~=~~=~~=~~=~~=~~=~~=~~=~~=~~=~~=~~=~~=~~=~~=~~=
    //    Output files for rendering
    // ~~=~~=~~=~~=~~=~~=~~=~~=~~=~~=~~=~~=~~=~~=~~=~~=~~=
    // Open the SV file for rendering
    FILE *sv_fp = fopen(svout.c_str(), "w");
    if(!sv_fp) {
             fprintf(stderr, "Error! unable to open the system verilog output file %s for rendering\n", svout.c_str());
             return -1;
    }

    // Open the CPP file for rendering
    FILE *cpp_fp = fopen(cppout.c_str(), "w");
    if(!cpp_fp) {
             fprintf(stderr, "Error! unable to open the C++ output file %s for rendering\n", cppout.c_str());
             return -1;
    }

    // ~~=~~=~~=~~=~~=~~=~~=~~=~~=~~=~~=~~=~~=~~=~~=~~=~~=

	// -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
	// Parse the JSON input and ensure that it is valid
	// -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
	FILE* fp = fopen(jsonin.c_str(), "r");
	if(!fp) {
             fprintf(stderr, "Error! unable to open the json input file %s\n", jsonin.c_str());
             return -1;
	}
	
	rapidjson::Document json_i;
	char readBuffer[65536];
	rapidjson::FileReadStream is(fp, readBuffer, sizeof(readBuffer)); 

	json_i.ParseStream(is);
	if(!json_i.IsObject()){
            fprintf(stderr, "Error! %s is not valid json, use jsonlint.com to validate it.\n", jsonin.c_str());
	    return -1;
	}
	
        VisStruct top_struct;	
	if(!silent)
	    fprintf(stdout, "Top-level struct is %s\n", json_i["struct_name"].GetString());
	top_struct.name(json_i["struct_name"].GetString());
         
    walkStructure(json_i, &top_struct, silent);

	fprintf(stdout, "\n\n");

      // render the system verilog struct	
      emitVerilog(sv_fp, top_struct);
    
      RenderCpp renderer(cpp_fp, top_struct); 
    

    } catch (std::exception& e) {
    	std::cerr << e.what() << "\n";
    }


}
